package edu.usc.haoyu.handler;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Assignment.Operator;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.Modifier.ModifierKeyword;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.WildcardType;

import edu.usc.haoyu.utils.BuilderResource;

/**
 * @author Haoyu
 * 
 */
public class ASTBuilder {

	private ASTBuilder(ICompilationUnit compilationUnit)
			throws JavaModelException {
		this.compilationUnit = compilationUnit;
		if (compilationUnit != null) {
			this.parsedCompilationUnit = parse(compilationUnit.getSource());
		} else {
			throw new NullPointerException("Null Compilation Unit");
		}
	}

	public static ASTBuilder newInstance(ICompilationUnit compilationUnit)
			throws JavaModelException {
		return new ASTBuilder(compilationUnit);
	}

	/**
	 * Original compilation unit
	 */
	private ICompilationUnit compilationUnit;

	/**
	 * Parsed compilation unit
	 */
	private CompilationUnit parsedCompilationUnit;

	/**
	 * Methods descriptions in the original compilation unit
	 */
	private List<String> methods = null;

	/**
	 * Class name of the original compilation unit
	 */
	private String className;

	/**
	 * Package name of the original compilation unit
	 */
	private String packageName;

	public String createBuilderInterface() throws JavaModelException {
		AST ast = AST.newAST(AST.JLS4);
		CompilationUnit compilationUnit = ast.newCompilationUnit();

		// create builder interface
		TypeDeclaration builderInterface = ast.newTypeDeclaration();
		TypeParameter typeParameter = ast.newTypeParameter();
		typeParameter.setName(ast.newSimpleName("T"));
		builderInterface.setInterface(true);
		builderInterface.setName(ast.newSimpleName("Builder"));

		Javadoc doc = ast.newJavadoc();

		TagElement tagElement = ast.newTagElement();
		TextElement comment = ast.newTextElement();
		comment.setText("Auto generated by Builder Engine");
		tagElement.fragments().add(comment);

		TagElement authorTag = ast.newTagElement();
		authorTag.setTagName("@author");
		TextElement author = ast.newTextElement();
		author.setText("Haoyu");
		authorTag.fragments().add(author);
		doc.tags().add(tagElement);
		doc.tags().add(authorTag);

		builderInterface.setJavadoc(doc);

		builderInterface.typeParameters().add(typeParameter);
		builderInterface.modifiers().add(
				ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
		compilationUnit.types().add(builderInterface);
		PackageDeclaration packageDeclaration = ast.newPackageDeclaration();
		packageDeclaration.setName(ast.newName(getPackageName()));
		compilationUnit.setPackage(packageDeclaration);

		MethodDeclaration build = ast.newMethodDeclaration();
		build.setName(ast.newSimpleName("build"));
		build.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
		build.setReturnType2(ast.newSimpleType(ast.newSimpleName(typeParameter
				.getName().getFullyQualifiedName())));
		builderInterface.bodyDeclarations().add(build);

		return compilationUnit.toString();
	}

	public String getClassName() throws JavaModelException {

		if (className != null) {
			return className;
		}

		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		className = classType.getName().getFullyQualifiedName();

		return className;
	}

	/**
	 * Parse the source into a compilation unit.
	 * 
	 * @param source
	 * @return
	 */
	private CompilationUnit parse(String source) {
		ASTParser parser = ASTParser.newParser(AST.JLS4);
		Map options = JavaCore.getOptions();
		JavaCore.setComplianceOptions(JavaCore.VERSION_1_7, options);
		parser.setCompilerOptions(options);
		parser.setSource(source.toCharArray());
		CompilationUnit cu = (CompilationUnit) parser.createAST(null);
		return cu;
	}

	/**
	 * 
	 * Get the package name of the original compilation unit
	 * 
	 * @return
	 * @throws JavaModelException
	 */
	public String getPackageName() throws JavaModelException {

		if (packageName != null) {
			return packageName;
		}

		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		packageName = parsedCompilationUnit.getPackage().getName()
				.getFullyQualifiedName();

		return packageName;
	}

	public List<String> getMethodDeclarations() throws JavaModelException {

		if (methods != null) {
			return methods;
		}

		methods = new ArrayList<String>();
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		for (Object type : classType.bodyDeclarations()) {
			if (type instanceof MethodDeclaration) {
				MethodDeclaration method = (MethodDeclaration) type;
				StringBuilder builder = new StringBuilder();
				builder.append(method.getName().getFullyQualifiedName());
				builder.append("(");
				for (Object svd : method.parameters()) {
					SingleVariableDeclaration param = (SingleVariableDeclaration) svd;
					builder.append(param.getType().toString());
					builder.append(", ");
				}
				if (builder.charAt(builder.length() - 1) == ' ') {
					builder.deleteCharAt(builder.length() - 1);
					builder.deleteCharAt(builder.length() - 1);
				}
				builder.append(")");
				methods.add(builder.toString());
			}
		}
		return methods;
	}

	public List<FieldDeclaration> getFieldDeclarations()
			throws JavaModelException {
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		ArrayList<FieldDeclaration> fields = new ArrayList<FieldDeclaration>();

		for (Object type : classType.bodyDeclarations()) {
			if (type instanceof FieldDeclaration) {
				fields.add((FieldDeclaration) type);
			}
		}
		return fields;
	}

	public int createInnerBuilderClass(int index, boolean firstMember,
			boolean lastMember) throws JavaModelException {
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);
		String className = classType.getName().getFullyQualifiedName();
		String builderClassName = className + "Builder";
		String builderParameterName = className + "builder";

		ArrayList<FieldDeclaration> fields = new ArrayList<FieldDeclaration>();

		int firstMemberIndex = -1;
		int lastMemberIndex = -1;
		int i = 0;

		for (Object type : classType.bodyDeclarations()) {
			if (type instanceof FieldDeclaration) {
				fields.add((FieldDeclaration) type);
				if (firstMemberIndex != -1) {
					firstMemberIndex = i;
				}
				lastMemberIndex = i;
			}
			i++;
		}

		if (firstMember) {
			index = firstMemberIndex - 1 >= 0 ? firstMemberIndex - 1 : 0;
		} else if (lastMember) {
			index = lastMemberIndex + 1;
		}

		AST ast = parsedCompilationUnit.getAST();

		// create builder interface
		TypeDeclaration builderClass = ast.newTypeDeclaration();
		TypeDeclaration builderInterface = ast.newTypeDeclaration();
		TypeParameter typeParameter = ast.newTypeParameter();
		typeParameter.setName(ast.newSimpleName(className));
		builderInterface.typeParameters().add(typeParameter);
		builderInterface.setName(ast.newSimpleName("Builder"));

		builderClass.setInterface(false);
		builderClass.setName(ast.newSimpleName(builderClassName));
		builderClass.modifiers().add(
				ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
		builderClass.modifiers().add(
				ast.newModifier(ModifierKeyword.FINAL_KEYWORD));
		builderClass.modifiers().add(
				ast.newModifier(ModifierKeyword.STATIC_KEYWORD));
		builderClass.superInterfaceTypes().add(
				ast.newSimpleType(ast.newName((builderInterface.getName()
						.getFullyQualifiedName()))));

		Javadoc doc = ast.newJavadoc();

		TagElement tagElement = ast.newTagElement();
		TextElement comment = ast.newTextElement();
		comment.setText("Auto generated by Builder Engine");
		tagElement.fragments().add(comment);

		TagElement authorTag = ast.newTagElement();
		authorTag.setTagName("@author");
		TextElement author = ast.newTextElement();
		author.setText("Haoyu");
		authorTag.fragments().add(author);
		doc.tags().add(tagElement);
		doc.tags().add(authorTag);

		builderClass.setJavadoc(doc);

		// PackageDeclaration packageDeclaration = ast.newPackageDeclaration();
		// packageDeclaration.setName(ast.newName("edu.usc"));
		// cu.setPackage(packageDeclaration);

		// create private constructor
		MethodDeclaration constructorDeclaration = ast.newMethodDeclaration();
		constructorDeclaration.setConstructor(true);
		constructorDeclaration.modifiers().add(
				ast.newModifier(ModifierKeyword.PRIVATE_KEYWORD));
		constructorDeclaration.setName(ast.newSimpleName(className));
		Block constructorBody = ast.newBlock();
		constructorDeclaration.setBody(constructorBody);

		SingleVariableDeclaration constructorParameter = ast
				.newSingleVariableDeclaration();
		constructorParameter.setName(ast.newSimpleName(builderParameterName));
		constructorParameter.setType(ast.newSimpleType(ast
				.newName(builderClassName)));
		constructorDeclaration.parameters().add(constructorParameter);

		for (FieldDeclaration field : fields) {

			VariableDeclarationFragment fieldVariableDeclarationFragment = (VariableDeclarationFragment) field
					.fragments().get(0);
			String fieldName = fieldVariableDeclarationFragment.getName()
					.getFullyQualifiedName();

			Assignment constructorAssignment = ast.newAssignment();

			FieldAccess buildFieldAccess = ast.newFieldAccess();
			buildFieldAccess.setExpression(ast
					.newSimpleName(builderParameterName));
			buildFieldAccess.setName(ast.newSimpleName(fieldName));

			FieldAccess thisFieldAccess = ast.newFieldAccess();
			thisFieldAccess.setExpression(ast.newThisExpression());
			thisFieldAccess.setName(ast.newSimpleName(fieldName));

			constructorAssignment.setLeftHandSide(thisFieldAccess);
			constructorAssignment.setOperator(Operator.ASSIGN);
			constructorAssignment.setRightHandSide(buildFieldAccess);
			constructorBody.statements().add(
					ast.newExpressionStatement(constructorAssignment));
		}

		classType.bodyDeclarations().add(index, constructorDeclaration);

		// create fields
		for (FieldDeclaration field : fields) {

			VariableDeclarationFragment fieldVariableDeclarationFragment = (VariableDeclarationFragment) field
					.fragments().get(0);
			String fieldName = fieldVariableDeclarationFragment.getName()
					.getFullyQualifiedName();
			Type fieldType = field.getType();

			VariableDeclarationFragment variableDeclarationFragment = ast
					.newVariableDeclarationFragment();
			variableDeclarationFragment.setName(ast.newSimpleName(fieldName));

			FieldDeclaration fieldDeclaration = ast
					.newFieldDeclaration(variableDeclarationFragment);
			fieldDeclaration.modifiers().add(
					ast.newModifier(ModifierKeyword.PRIVATE_KEYWORD));
			fieldDeclaration.setType(createTypeWithFieldType(ast, fieldType));
			builderClass.bodyDeclarations().add(fieldDeclaration);
		}

		// create field method
		for (FieldDeclaration field : fields) {

			VariableDeclarationFragment fieldVariableDeclarationFragment = (VariableDeclarationFragment) field
					.fragments().get(0);
			String fieldName = fieldVariableDeclarationFragment.getName()
					.getFullyQualifiedName();
			Type fieldType = field.getType();
			Javadoc fieldDoc = field.getJavadoc();

			MethodDeclaration fieldMethod = ast.newMethodDeclaration();
			fieldMethod.setName(ast.newSimpleName(BuilderResource
					.capatizeFirstCharacter(fieldName)));
			fieldMethod.modifiers().add(
					ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
			fieldMethod.setReturnType2(ast.newSimpleType(ast
					.newSimpleName(builderClass.getName()
							.getFullyQualifiedName())));
			fieldMethod.setJavadoc(createSimpleDoc(ast, className, fieldName));

			Block fieldBlock = ast.newBlock();
			fieldMethod.setBody(fieldBlock);

			SingleVariableDeclaration fieldParameter = ast
					.newSingleVariableDeclaration();
			fieldParameter.setName(ast.newSimpleName(fieldName));
			fieldParameter.setType(createTypeWithFieldType(ast, fieldType));
			fieldMethod.parameters().add(fieldParameter);

			Assignment assigment = ast.newAssignment();
			FieldAccess fieldAccess = ast.newFieldAccess();
			fieldAccess.setExpression(ast.newThisExpression());
			fieldAccess.setName(ast.newSimpleName(fieldName));

			assigment.setLeftHandSide(fieldAccess);
			assigment.setOperator(Operator.ASSIGN);
			assigment.setRightHandSide(ast.newSimpleName(fieldName));

			fieldBlock.statements().add(ast.newExpressionStatement(assigment));

			ReturnStatement retFieldStatement = ast.newReturnStatement();
			retFieldStatement.setExpression(ast.newThisExpression());
			fieldBlock.statements().add(retFieldStatement);

			builderClass.bodyDeclarations().add(fieldMethod);
		}

		// create build method
		MethodDeclaration build = ast.newMethodDeclaration();
		build.setName(ast.newSimpleName("build"));
		build.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
		build.setReturnType2(ast.newSimpleType(ast.newSimpleName(typeParameter
				.getName().getFullyQualifiedName())));
		Block retBody = ast.newBlock();
		build.setBody(retBody);

		ReturnStatement retSta = ast.newReturnStatement();
		ClassInstanceCreation variable = ast.newClassInstanceCreation();
		variable.setType(ast.newSimpleType(ast.newName(className)));
		variable.arguments().add(ast.newThisExpression());
		retSta.setExpression(variable);
		retBody.statements().add(retSta);

		builderClass.bodyDeclarations().add(build);

		classType.bodyDeclarations().add(index + 1, builderClass);

		return index + 1;
	}

	public void removeInnerBuilderClass() throws JavaModelException {

		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);
		String className = classType.getName().getFullyQualifiedName();
		String builderClassName = className + "Builder";

		for (int i = 0; i < classType.bodyDeclarations().size(); i++) {
			Object em = classType.bodyDeclarations().get(i);
			if (em instanceof MethodDeclaration) {
				MethodDeclaration method = (MethodDeclaration) em;
				if (method.getName().getFullyQualifiedName().equals(className)
						&& method.isConstructor()) {
					classType.bodyDeclarations().remove(i);
					i--;
				}
			} else if (em instanceof TypeDeclaration) {
				TypeDeclaration builder = (TypeDeclaration) em;
				if (builder.getName().getFullyQualifiedName()
						.equals(builderClassName)) {
					classType.bodyDeclarations().remove(i);
					i--;
				}

			}
		}

	}

	public int createInnerJSONMethods(int index) throws JavaModelException {
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		String className = classType.getName().getFullyQualifiedName();

		List<ImportDeclaration> imports = parsedCompilationUnit.imports();

		AST ast = parsedCompilationUnit.getAST();

		ArrayList<FieldDeclaration> fields = new ArrayList<FieldDeclaration>();

		for (Object type : classType.bodyDeclarations()) {
			if (type instanceof FieldDeclaration) {
				fields.add((FieldDeclaration) type);
			}
		}

		ImportDeclaration JSONObjectImport = ast.newImportDeclaration();
		JSONObjectImport.setName(ast.newQualifiedName(
				ast.newQualifiedName(ast.newName("org"),
						ast.newSimpleName("json")),
				ast.newSimpleName("JSONObject")));

		ImportDeclaration JSONExceptionImport = ast.newImportDeclaration();
		JSONExceptionImport.setName(ast.newQualifiedName(
				ast.newQualifiedName(ast.newName("org"),
						ast.newSimpleName("json")),
				ast.newSimpleName("JSONException")));

		boolean JSONimported = false;
		boolean JSONEximported = false;

		for (ImportDeclaration em : imports) {
			if (em.getName().getFullyQualifiedName()
					.equals(JSONObjectImport.getName().getFullyQualifiedName())) {
				JSONimported = true;
			} else if (em
					.getName()
					.getFullyQualifiedName()
					.equals(JSONExceptionImport.getName()
							.getFullyQualifiedName())) {
				JSONEximported = true;
			}
		}

		if (!JSONimported) {
			imports.add(JSONObjectImport);
		}
		if (!JSONEximported) {
			imports.add(JSONExceptionImport);
		}

		MethodDeclaration toJSONDeclaration = createToJSONMethod(ast, fields);
		MethodDeclaration fromJSONDeclaration = createfromJSONMethod(ast,
				fields, className);

		classType.bodyDeclarations().add(index, toJSONDeclaration);
		classType.bodyDeclarations().add(index + 1, fromJSONDeclaration);

		return index + 1;

	}

	public void removeInnerJSONMethods() throws JavaModelException {
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		String className = classType.getName().getFullyQualifiedName();

		for (int i = 0; i < classType.bodyDeclarations().size(); i++) {
			Object em = classType.bodyDeclarations().get(i);
			if (em instanceof MethodDeclaration) {
				MethodDeclaration method = (MethodDeclaration) em;
				if (method.getName().getFullyQualifiedName().equals("toJSON")) {
					classType.bodyDeclarations().remove(i);
					i--;
				}
				if (method.getName().getFullyQualifiedName().equals("fromJSON")) {
					classType.bodyDeclarations().remove(i);
					i--;
				}
			}
		}
	}

	private MethodDeclaration createfromJSONMethod(AST ast,
			List<FieldDeclaration> fields, String className) {
		MethodDeclaration fromJSONMethod = ast.newMethodDeclaration();
		fromJSONMethod.modifiers().add(
				ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
		fromJSONMethod.setReturnType2(ast.newSimpleType(ast
				.newSimpleName(className)));
		SingleVariableDeclaration param = ast.newSingleVariableDeclaration();
		param.setName(ast.newSimpleName("json"));
		param.setType(ast.newSimpleType(ast.newName("JSONObject")));
		fromJSONMethod.parameters().add(param);
		fromJSONMethod.thrownExceptions().add(ast.newName("JSONException"));

		fromJSONMethod.setName(ast.newSimpleName("fromJSON"));
		Block fromJSONBody = ast.newBlock();
		fromJSONMethod.setBody(fromJSONBody);

		IfStatement ifStatement = ast.newIfStatement();
		InfixExpression isNull = ast.newInfixExpression();
		isNull.setLeftOperand(ast.newName("json"));
		isNull.setOperator(InfixExpression.Operator.EQUALS);
		isNull.setRightOperand(ast.newNullLiteral());
		ifStatement.setExpression(isNull);
		ReturnStatement retIfSta = ast.newReturnStatement();
		retIfSta.setExpression(ast.newNullLiteral());
		ifStatement.setThenStatement(retIfSta);

		fromJSONBody.statements().add(ifStatement);

		for (FieldDeclaration field : fields) {
			VariableDeclarationFragment fieldVariableDeclarationFragment = (VariableDeclarationFragment) field
					.fragments().get(0);
			String fieldName = fieldVariableDeclarationFragment.getName()
					.getFullyQualifiedName();
			Type fieldType = field.getType();

			MethodInvocation getJSON = ast.newMethodInvocation();
			getJSON.setName(ast.newSimpleName("get"));
			StringLiteral literal = ast.newStringLiteral();
			literal.setLiteralValue(fieldName);
			getJSON.arguments().add(literal);
			getJSON.setExpression(ast.newName("json"));

			CastExpression castExpression = ast.newCastExpression();
			castExpression.setExpression(getJSON);
			castExpression.setType(createTypeWithFieldType(ast, fieldType));

			Assignment assignment = ast.newAssignment();
			FieldAccess fieldAccess = ast.newFieldAccess();
			fieldAccess.setExpression(ast.newThisExpression());
			fieldAccess.setName(ast.newSimpleName(fieldName));

			assignment.setLeftHandSide(fieldAccess);
			assignment.setOperator(Operator.ASSIGN);
			assignment.setRightHandSide(castExpression);

			fromJSONBody.statements().add(
					ast.newExpressionStatement(assignment));
		}
		ReturnStatement retSta = ast.newReturnStatement();
		retSta.setExpression(ast.newThisExpression());

		fromJSONBody.statements().add(retSta);

		return fromJSONMethod;
	}

	private MethodDeclaration createToJSONMethod(AST ast,
			List<FieldDeclaration> fields) {
		MethodDeclaration toJSONMethod = ast.newMethodDeclaration();
		toJSONMethod.modifiers().add(
				ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
		toJSONMethod.setReturnType2(ast.newSimpleType(ast
				.newSimpleName("JSONObject")));
		toJSONMethod.setName(ast.newSimpleName("toJSON"));
		toJSONMethod.thrownExceptions().add(ast.newName("JSONException"));

		Block toJSONBody = ast.newBlock();
		toJSONMethod.setBody(toJSONBody);

		ClassInstanceCreation jsonObj = ast.newClassInstanceCreation();
		jsonObj.setType(ast.newSimpleType(ast.newName("JSONObject")));

		VariableDeclarationFragment declarationFragment = ast
				.newVariableDeclarationFragment();
		declarationFragment.setInitializer(jsonObj);
		declarationFragment.setName(ast.newSimpleName("json"));

		VariableDeclarationExpression newJSON = ast
				.newVariableDeclarationExpression(declarationFragment);
		newJSON.setType(ast.newSimpleType(ast.newName("JSONObject")));

		toJSONBody.statements().add(ast.newExpressionStatement(newJSON));

		MethodInvocation putJSON;
		for (FieldDeclaration field : fields) {

			VariableDeclarationFragment fieldVariableDeclarationFragment = (VariableDeclarationFragment) field
					.fragments().get(0);
			String fieldName = fieldVariableDeclarationFragment.getName()
					.getFullyQualifiedName();
			Type fieldType = field.getType();

			putJSON = ast.newMethodInvocation();
			putJSON.setName(ast.newSimpleName("put"));

			StringLiteral key = ast.newStringLiteral();
			key.setLiteralValue(fieldName);
			putJSON.arguments().add(key);

			FieldAccess valueAccess = ast.newFieldAccess();
			valueAccess.setExpression(ast.newThisExpression());
			valueAccess.setName(ast.newSimpleName(fieldName));

			putJSON.arguments().add(valueAccess);
			putJSON.setExpression(ast.newName("json"));

			toJSONBody.statements().add(ast.newExpressionStatement(putJSON));

		}
		ReturnStatement retSta = ast.newReturnStatement();
		retSta.setExpression(ast.newName("json"));

		toJSONBody.statements().add(retSta);

		return toJSONMethod;
	}

	/**
	 * Internal Method
	 * 
	 * @param ast
	 * @param fieldType
	 * @param castExpression
	 */
	private Type createTypeWithFieldType(AST ast, Type fieldType) {
		if (fieldType instanceof PrimitiveType) {
			return ast.newPrimitiveType(((PrimitiveType) fieldType)
					.getPrimitiveTypeCode());
		} else if (fieldType instanceof SimpleType) {
			return ast.newSimpleType(ast.newName(((SimpleType) fieldType)
					.getName().getFullyQualifiedName()));
		} else if (fieldType instanceof ArrayType) {
			ArrayType type = (ArrayType) fieldType;
			return ast
					.newArrayType(type.getElementType(), type.getDimensions());
		} else if (fieldType instanceof QualifiedType) {
			QualifiedType qualifiedType = (QualifiedType) fieldType;
			return ast.newQualifiedType(qualifiedType.getQualifier(),
					qualifiedType.getName());
		} else if (fieldType instanceof SimpleType) {
			return ast.newSimpleType(ast.newName(((SimpleType) fieldType)
					.getName().getFullyQualifiedName()));
		} else if (fieldType instanceof ParameterizedType) {
			return ast.newParameterizedType(((ParameterizedType) fieldType)
					.getType());
		} else if (fieldType instanceof UnionType) {
			return ast.newUnionType();
		} else if (fieldType instanceof WildcardType) {
			return ast.newWildcardType();
		}
		return null;
	}

	/**
	 * Deep copy Java doc
	 * 
	 * @param ast
	 * @param doc
	 * @return fully copied java doc
	 */
	private Javadoc copyJavadoc(AST ast, Javadoc doc) {
		Javadoc copy = ast.newJavadoc();
		if (doc.tags() == null) {
			copy.setComment(doc.getComment());
			return copy;
		}
		for (Object em : doc.tags()) {
			if (em instanceof TagElement) {
				TagElement tag = (TagElement) em;
				TagElement copyTag = ast.newTagElement();
				copyTag.setTagName(tag.getTagName());
				for (Object et : tag.fragments()) {
					/*
					 * 
					 * TextElement Name MethodRef MemberRef
					 */
					if (et instanceof TextElement) {
						TextElement text = (TextElement) et;
						TextElement copyText = ast.newTextElement();
						copyText.setText(text.getText());
						copyTag.fragments().add(copyText);
					} else if (et instanceof Name) {
						Name name = (Name) et;
						Name copyName = ast.newName(name
								.getFullyQualifiedName());
						copyTag.fragments().add(copyName);
					} else if (et instanceof MethodRef) {
						MethodRef ref = (MethodRef) et;
						MethodRef copyRef = ast.newMethodRef();
						copyRef.setName(ast.newSimpleName(ref.getName()
								.getFullyQualifiedName()));
						copyRef.setQualifier(ast.newName(ref.getQualifier()
								.getFullyQualifiedName()));
						for (Object me : ref.parameters()) {
							if (me instanceof MethodRefParameter) {
								MethodRefParameter mrp = (MethodRefParameter) me;
								MethodRefParameter copyMRP = ast
										.newMethodRefParameter();
								copyMRP.setName(ast.newSimpleName(mrp.getName()
										.getFullyQualifiedName()));
								copyMRP.setType(createTypeWithFieldType(ast,
										mrp.getType()));
								copyMRP.setVarargs(mrp.isVarargs());
								copyRef.parameters().add(copyMRP);
							}
						}
						copyTag.fragments().add(copyRef);
					} else if (et instanceof MemberRef) {
						MemberRef ref = (MemberRef) et;
						MemberRef copyRef = ast.newMemberRef();
						copyRef.setName(ast.newSimpleName(ref.getName()
								.getFullyQualifiedName()));
						copyRef.setQualifier(ast.newName(ref.getName()
								.getFullyQualifiedName()));
						copyTag.fragments().add(copyRef);
					}
				}
				copy.tags().add(copyTag);
			}
		}

		return copy;
	}

	private Javadoc createSimpleDoc(AST ast, String className, String fieldName) {
		Javadoc doc = ast.newJavadoc();
		TagElement tag = ast.newTagElement();
		tag.setTagName("@see");
		MemberRef memberRef = ast.newMemberRef();
		memberRef.setName(ast.newSimpleName(fieldName));
		memberRef.setQualifier(ast.newName(className));
		tag.fragments().add(memberRef);
		doc.tags().add(tag);
		return doc;
	}

	/**
	 * @return
	 */
	public String getContent() {
		if (parsedCompilationUnit != null) {
			return parsedCompilationUnit.toString();
		} else {
			return null;
		}
	}

	private static void example() {
		AST ast = AST.newAST(AST.JLS4);
		CompilationUnit compilationUnit = ast.newCompilationUnit();

		List<ImportDeclaration> imports = compilationUnit.imports();
		// 创建类
		TypeDeclaration programClass = ast.newTypeDeclaration();
		programClass.setName(ast.newSimpleName("HelloWorld"));
		programClass.modifiers().add(
				ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
		compilationUnit.types().add(programClass);
		// Javadoc doc = ast.newJavadoc();
		//
		// TagElement tagElement = ast.newTagElement();
		// TextElement comment = ast.newTextElement();
		// comment.setText("Auto generated by Builder Engine");
		// tagElement.fragments().add(comment);
		//
		// TagElement authorTag = ast.newTagElement();
		// authorTag.setTagName("@author");
		// TextElement author = ast.newTextElement();
		// author.setText("Haoyu");
		// authorTag.fragments().add(author);
		// doc.tags().add(tagElement);
		// doc.tags().add(authorTag);

		Javadoc doc = ast.newJavadoc();
		TagElement tag = ast.newTagElement();
		tag.setTagName("@see");
		MemberRef memberRef = ast.newMemberRef();
		memberRef.setName(ast.newSimpleName("field"));
		memberRef.setQualifier(ast.newName("Haha"));
		tag.fragments().add(memberRef);
		doc.tags().add(tag);
		programClass.setJavadoc(doc);

		ImportDeclaration JSONObjectImport = ast.newImportDeclaration();
		JSONObjectImport.setName(ast.newQualifiedName(
				ast.newQualifiedName(ast.newName("org"),
						ast.newSimpleName("json")),
				ast.newSimpleName("JSONObject")));

		ImportDeclaration JSONExceptionImport = ast.newImportDeclaration();
		JSONExceptionImport.setName(ast.newQualifiedName(
				ast.newQualifiedName(ast.newName("org"),
						ast.newSimpleName("json")),
				ast.newSimpleName("JSONException")));

		imports.add(JSONObjectImport);
		imports.add(JSONExceptionImport);
		// 创建包
		PackageDeclaration packageDeclaration = ast.newPackageDeclaration();
		packageDeclaration.setName(ast.newName("cn.shenyanchao.hello"));
		compilationUnit.setPackage(packageDeclaration);

		MethodDeclaration main = ast.newMethodDeclaration();
		main.setName(ast.newSimpleName("main"));
		main.modifiers().add(
				ast.newModifier(Modifier.ModifierKeyword.PUBLIC_KEYWORD));
		main.modifiers().add(
				ast.newModifier(Modifier.ModifierKeyword.STATIC_KEYWORD));
		main.setReturnType2(ast.newPrimitiveType(PrimitiveType.VOID));
		programClass.bodyDeclarations().add(main);
		Block mainBlock = ast.newBlock();
		main.setBody(mainBlock);

		// 给main方法定义String[]参数
		SingleVariableDeclaration mainParameter = ast
				.newSingleVariableDeclaration();
		mainParameter.setName(ast.newSimpleName("arg"));
		mainParameter.setType(ast.newArrayType(ast.newSimpleType(ast
				.newName("String"))));
		main.parameters().add(mainParameter);

		MethodInvocation println = ast.newMethodInvocation();
		println.setName(ast.newSimpleName("println"));
		// 生成String类型的常量
		StringLiteral s = ast.newStringLiteral();
		s.setLiteralValue("Hello World");
		println.arguments().add(s);

		println.setExpression(ast.newName("System.out"));

		mainBlock.statements().add(ast.newExpressionStatement(println));

		System.out.println(compilationUnit.toString());
	}

	public boolean containsAllFields() throws JavaModelException {
		if (parsedCompilationUnit == null) {
			parsedCompilationUnit = parse(compilationUnit.getSource());
		}

		TypeDeclaration classType = (TypeDeclaration) parsedCompilationUnit
				.types().get(0);

		className = classType.getName().getFullyQualifiedName();

		TypeDeclaration builderClass = null;

		for (Object em : classType.bodyDeclarations()) {
			if (em instanceof TypeDeclaration) {
				TypeDeclaration td = (TypeDeclaration) em;
				if ((className + "Builder").equals(td.getName()
						.getFullyQualifiedName())) {
					builderClass = td;
					break;
				}
			}
		}

		if (builderClass == null) {
			return false;
		}

		List<FieldDeclaration> builderFields = new ArrayList<FieldDeclaration>();

		for (Object em : builderClass.bodyDeclarations()) {
			if (em instanceof FieldDeclaration) {
				builderFields.add((FieldDeclaration) em);
			}
		}

		List<FieldDeclaration> fields = getFieldDeclarations();

		int sameSize = 0;
		boolean exists = false;

		if (fields.size() != builderFields.size()) {
			return false;
		}

		for (FieldDeclaration builderField : builderFields) {
			for (FieldDeclaration field : fields) {
				if (isEqual(builderField, field)) {
					exists = true;
				}
			}
			if (exists) {
				exists = false;
				sameSize++;
			}
		}

		if (sameSize == builderFields.size()) {
			return true;
		}

		return false;
	}

	private boolean isEqual(FieldDeclaration field1, FieldDeclaration field2) {

		VariableDeclarationFragment fieldVariableDeclarationFragment1 = (VariableDeclarationFragment) field1
				.fragments().get(0);
		String fieldName1 = fieldVariableDeclarationFragment1.getName()
				.getFullyQualifiedName();
		Type fieldType1 = field1.getType();

		VariableDeclarationFragment fieldVariableDeclarationFragment2 = (VariableDeclarationFragment) field2
				.fragments().get(0);
		String fieldName2 = fieldVariableDeclarationFragment2.getName()
				.getFullyQualifiedName();
		Type fieldType2 = field2.getType();

		if (fieldName1.equals(fieldName2)) {
			boolean b1 = fieldType1.isArrayType() && fieldType2.isArrayType();
			boolean b2 = fieldType1.isParameterizedType()
					&& fieldType2.isParameterizedType();
			boolean b3 = fieldType1.isPrimitiveType()
					&& fieldType2.isPrimitiveType();
			boolean b4 = fieldType1.isQualifiedType()
					&& fieldType2.isQualifiedType();
			boolean b5 = fieldType1.isSimpleType() && fieldType2.isSimpleType();
			boolean b6 = fieldType1.isUnionType() && fieldType2.isUnionType();
			boolean b7 = fieldType1.isWildcardType()
					&& fieldType2.isWildcardType();
			if (b1) {
				ArrayType a1 = (ArrayType) fieldType1;
				return true;
			}
			if (b2) {
				ParameterizedType p1 = (ParameterizedType) fieldType1;
			}
			if (b3) {
				PrimitiveType p1 = (PrimitiveType) fieldType1;
				PrimitiveType p2 = (PrimitiveType) fieldType2;
				return p1.getPrimitiveTypeCode().equals(
						p2.getPrimitiveTypeCode());
			}
			if (b4) {
				QualifiedType q1 = (QualifiedType) fieldType1;
			}
			if (b5) {
				SimpleType st1 = (SimpleType) fieldType1;
				SimpleType st2 = (SimpleType) fieldType2;
				return st1.getName().getFullyQualifiedName()
						.equals(st2.getName().getFullyQualifiedName());
			}
			if (b6) {
				UnionType ut1 = (UnionType) fieldType1;
				return true;
			}
			if (b7) {
				return true;
			}
		}

		return true;
	}

	public static void main(String[] args) {
		example();
	}
}
